(ns base
  :doc "Collection of functions and macros to be included by default with the Simba language."
  :date-created "27 January 2022"
  :author "Jérémie Vaney"

  ;; CONTROL FLOW

  (def defn
    :doc "Shorthand for defining functions.
          The metadata is not yet preserved as it should, because the implementation cannot yet handle named parameters."
    ;; notes on multiple dispatch: the multiple dispatch mechanism should be like the one
    ;; in Julia, with dispatch based on arity, type, and the option for optional and keyword arguments,
    ;; with the optional ability to dispatch on an arbitrary function
    (fn [name args & expr]
      :macro true
      `(def ~name
         (fn ~args
          ;;  :name 
           ~@expr))))

  (def defmacro
    (fn [name args & expr]
      :macro true
      `(def ~name
         (fn ~args :macro true ~@expr))))

  ;; (defmacro let [bindings & forms]
  ;;   `(fn []))

  (defmacro comment [& body]
    nil)

  (defmacro when [condition & clauses]
    `(if ~condition
       (do ~@clauses)
       nil))

  (defmacro cond [& clauses :else nil]
    (when clauses
      (sexp 'if (first clauses)
            (if (rest clauses)
              (second clauses)
              (throw (exception "`cond` requires an even number of forms")))
            (prepend-sexp 'cond (rest (rest clauses))))))

  (defmacro assign [name value]
    :doc "Shorthand to return a value after defining it.
          Analog of the Python 'walrus' operator."
    `(do (def ~name ~value) ~name))

  (defmacro import [module-name]
    :doc "Like require, but imports a Python module instead."
    `(def ~module-name
       (py-exec ~(+ "import " (str module-name) "; " (str module-name)))))

  ;; MULTIMETHODS

  ;; (defn register [var fn]
  ;;   (try
  ;;     ))

  ;; (defmacro defmethod [name args & body]
  ;;   `(if (defined ~name)
  ;;      (register
  ;;       (fn ~args
  ;;         ;; :name ~name
  ;;         ~@body))))

  (defmacro is-assigned [var]
    :doc "Returns true if the variable has a binding in the current environment, else false."
    `(try ~var true
          :catch false))

  (defmacro defn [name args & body]
    `(if (is-assigned ~name)
       (.register (fn ~args ~@body) ~name)
       (def ~name (py/Multi (fn ~args ~@body)))))

  (defn mymulti [a]
    (+ a 10))

  (defn mymulti [a b]
    (+ a b 10))

  (defn mymulti [& args]
    (+ args))

  ;; (print (mymulti 10))
  ;; (print (mymulti 13 12))
  ;; (print (mymulti 13 12 10))

  ;; SEQUENCES

  (defn first [seq]
    (at 0 seq))

  (defn rest [seq]
    (between 1 nil seq))

  (defn rrest [seq]
    (rest (rest seq)))

  (defn second [seq]
    (first (rest seq)))

  (defn take [n seq]
    (between 0 n seq))

  (defn take-last [n seq]
    (between (- n) nil seq))

  ;; COMBINATORS

  (defmacro apply [f & args]
    :doc "Applies the function f to the arguments x."
    (def l (count args))
    (cond
      (= 0 l) `(~f)
      (= 1 l) `(~f ~@(first args))
      (= 2 l) `(~f ~@(prepend (first args) (second args)))
      ;; (< 2 l) `(~f ~@(concat (between 0 -1 args) (at -1 args)))
      (< 2 l) `(~f ~@(concat (take (- (count args) 1) args) (first (take-last 1 args))))
      ;
      ))

  (defn identity [x]
    :doc "Returns its argument."
    x)

  (def a 30)
  ;; (print (apply + [1 2 (* a 30)]))

  (def thrush (fn [a b] (b a)))

  (defn compose [] identity)
  (defn compose [f] f)
  (defn compose [f g]
    :doc "An extended version of the bluebird combinator."
    (fn [& args]
      (f (apply g args))))

  ;; ((fn [& args]
  ;;     (not (apply = args))) 1 2 3)

  ;; (print ((fn [& args]
  ;;           (print args)
  ;;           (apply = args)) 2 2))

  ;; (defn complement [predicate]
  ;;   :doc "Returns the logical complement of a predicate."
  ;;   (compose not predicate))

  ;; REDUCERS AND TRANSDUCERS



  ;; PREDICATES

  (defn complement [predicate]
    (fn [& args] (not (apply predicate args))))

  (defn not= [a b]
    (not (= a b)))

  (defn is-empty [coll]
    (= 0 (count coll)))

  (defn is-odd [n]
    (= (% 2 n) 0))

  (defn is-even [n]
    (complement is-odd))

  ; or and and implemented as macros

  (defmacro or [& clauses]
    ;; or is the disjunction operator
    ;; the empty disjunction is false by convention
    (cond (is-empty clauses) false
          (= 1 (count clauses)) (first clauses)
          true `(do (def cl ~(first clauses))
                    (if cl cl (or ~@(rest clauses))))))

  ;; (defmacro and [& clauses]
  ;;   ;; by convention the empty conjuntion is true
  ;;   (sexp))

  ;; SEQUENCES

  (defn map [f coll]
    ;; I am worried this may be an extremely naive implementation - TCO?
    (def r (rest coll))
    (prepend (f (first coll))
             (if r
               (map f r)
               [])))

  ;; (comment
  ;;   "The Clojure definition. Note that the implementation is lazy, and that calling map without a collection returns a transducer."
  ;;   ([f]
  ;;    (fn [rf]
  ;;      (fn
  ;;        ([] (rf))
  ;;        ([result] (rf result))
  ;;        ([result input]
  ;;         (rf result (f input)))
  ;;        ([result input & inputs]
  ;;         (rf result (apply f input inputs))))))
  ;;   ([f coll]
  ;;    (lazy-seq
  ;;     (when-let [s (seq coll)]
  ;;       (if (chunked-seq? s)
  ;;         (let [c    (chunk-first s)
  ;;               size (int (count c))
  ;;               b    (chunk-buffer size)]
  ;;           (dotimes [i size]
  ;;             (chunk-append b (f (.nth c i))))
  ;;           (chunk-cons (chunk b) (map f (chunk-rest s))))
  ;;         (cons (f (first s)) (map f (rest s))))))))

  (defn filter [predicate coll]
    ;; this function should also return a transducer when no collection is provided
    (def [f (first coll)
          r (rest coll)])
    (if (predicate f)
      (prepend f (filter predicate r))
      (filter predicate r)))

  ;; (defn reduce [f coll initial])

  ;; (defn odds [])


  ;; (defn evens [seq]
  ;;   ;; from a sequence, returns a sequence containing all of its elements with pair indexes
  ;;   ;; without losing order
  ;;   (def new-seq (empty seq))
  ;;   (when seq
  ;;     (append (first seq) new-seq)))

  ;; COLLECTIONS

  ;; METAPROGRAMMING

  (defmacro pme [expr]
    ;; stands for 'print-macro-expansion'
    `(print
      (macroexpand ~expr)))

  ;; TESTING
  ;; the test library is baked into the base library, because it is so lightweight and performance is not a huge concern

  (def *tests-have-failed* false)

  (defn single-test [name test result]
    (when (not (= test result))
      (def *tests-have-failed* true)
      (prn "❗️ Test failed: `" name "` was expected to be " result " but got " test " instead. \n")))

  (defmacro test [& tests]
    (if (is-instance (first tests) str)
      `(do (def *section-name* ~(first tests))
           ~(when (rest tests)
              `(test ~@(rest tests))))
      `(do
         (single-test *section-name* ~(first tests) ~(second tests))
         ~(when (rrest tests)
            `(test ~@(rrest tests))))))

  (defmacro tests [name & tests]
    `(do
       (def *section-name* ~name)
       (prn "ℹ️ Testing `" ~name "`\n")
       (test ~@tests)
       (if *tests-have-failed*
         (prn "❌ Tests completed with some failures. \n")
         (prn "✅ Tests completed without failures. \n"))))

  (defmacro time [& forms]
    `(do (def t (date))
         ~@forms
         (- (date) t)))

  (defmacro pmt [& forms]
    `(print (measure-time ~@forms)))

  (comment "Various comments about the base library."
    
    "I have name resolution bugs, sometimes if a symbol is not found the interpreter will go into an infinite loop instead. Also, there are bugs when I try to namespace-qualify the symbols: it simply doesn't work."

    (defmacro do [& expressions]
      :doc "Serves as an example to show that `do` is easily defined in terms of only function application.
          However for practical purposes `do` is included as a special form in the interpeter."
      `((fn []
          ~@expressions)))))
