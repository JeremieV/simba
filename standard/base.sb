(ns base
  :doc "Collection of functions and macros to be included by default with the Simba language."
  :date-created "27 January 2022"
  :author "Jérémie Vaney"

  ;; CONTROL FLOW

  (def defn
    :doc "Shorthand for defining functions.
          The metadata is not yet preserved as it should, because the implementation cannot yet handle named parameters."
    ;; notes on multiple dispatch: the multiple dispatch mechanism should be like the one
    ;; in Julia, with dispatch based on arity, type, and the option for optional and keyword arguments,
    ;; with the optional ability to dispatch on an arbitrary function
    (fn [name & body]
      :macro true
      `(def ~name
         (fn ~@body
           :name '(str name))))) ;; the keyword works here BUT the argument is evaluated

  (def defmacro
    (fn [name args & expr]
      :macro true
      `(def ~name
         (fn ~args :macro true ~@expr))))

  (defmacro is-assigned? [var]
    :doc "Returns true if the variable has a binding in the current environment, else false."
    `(try ~var true
          :catch false))

  (defmacro defn [name & body]
    :doc "Defines a function."
    `(if (is-assigned? ~name)
       (.register (fn ~@body) ~name)
       (def ~name (fn ~@body))))

  ;; (defmacro let [bindings & forms]
  ;;   `(fn []))

  (defmacro comment [& body]
    nil)

  (defmacro when [condition & clauses]
    :doc "Evaluates test. If logical true, evaluates body in an implicit do."
    `(if ~condition
       (do ~@clauses)
       nil))

  (defmacro when-not [condition & clauses]
    :doc "Evaluates test. If logical false, evaluates body in an implicit do."
    `(if ~condition
       nil
       (do ~@clauses)))

  (defmacro cond [& clauses :else nil]
    (when clauses
      (sexp 'if (first clauses)
            (if (rest clauses)
              (second clauses)
              (throw (exception "`cond` requires an even number of forms")))
            (prepend-sexp 'cond (rest (rest clauses))))))

  (defmacro assign [name value]
    :doc "Shorthand to return a value after defining it.
          Analog of the Python 'walrus' operator."
    `(do (def ~name ~value) ~name))

  (defmacro import [module-name]
    :doc "Like require, but imports a Python module instead."
    `(def ~module-name
       (py-exec ~(+ "import " (str module-name) "; " (str module-name)))))

  (import base_functions)
  (import toolz)

  (defmacro assert-args [& pairs]
    :private true
    :doc "Used to assert that certain macros are called correctly."
    `(do (when-not ~(first pairs)
           (throw (py/IllegalArgumentException
                   (str (first ~'&form) " requires " ~(second pairs) " in " ~'*ns* ":" (:line (meta ~'&form))))))
         ~(let [more (nnext pairs)]
            (when more
              (vector `assert-args more)))))

  ;; MULTIMETHODS

  ;; (defmacro defmethod [name args & body]
  ;;   `(if (defined ~name)
  ;;      (register
  ;;       (fn ~args
  ;;         ;; :name ~name
  ;;         ~@body))))

  (defn inc [n]
    (+ n 1))

  (defn dec [n]
    (- n 1))

  ;; TYPES

  (defn vector? [x]
    (instance? x Vector))

  (defn map? [x]
    (instance? x HashMap))

  ;; SEQUENCES

  (def seq base_functions/sb_seq)
  (def sort toolz/sorted)

  (defn empty [s]
    :doc "Returns an empty sequence of the type of s."
    (cond
      (vector? s) []
      (map? s) {}
      true ((type s))))

  (defn cons [a b]
    (concat [a] b))

  (defn first [s]
    (at 0 s))

  (defn rest [s]
    (if (seq s)
      (between 1 nil s)
      (empty s)))

  (defn rrest [s]
    (rest (rest s)))

  (defn next [s]
    :doc "next is like rest except that it returns nil on an empty seq"
    (if (seq s)
      (between 1 nil s)
      nil))

  (defn nnext [s]
    (next (next s)))

  (defn second [s]
    (first (rest s)))

  (defn take [n s]
    (between 0 n s))

  (defn take-last [n s]
    (between (- n) nil s))

  ;; COMBINATORS

  (defmacro apply [f & args]
    :doc "Applies the function f to the arguments x."
    (def l (count args))
    (cond
      (= 0 l) `(~f)
      (= 1 l) `(~f ~@(first args))
      (= 2 l) `(~f ~@(prepend (first args) (second args)))
      ;; (< 2 l) `(~f ~@(concat (between 0 -1 args) (at -1 args)))
      (< 2 l) `(~f ~@(concat (take (- (count args) 1) args) (first (take-last 1 args))))
      ;
      ))

  (defn identity [x]
    :doc "Returns its argument."
    x)

  (def thrush (fn [a b] (b a)))

  (defn compose [] identity)
  (defn compose [f] f)
  (defn compose [f g]
    :doc "An extended version of the bluebird combinator."
    (fn [& args]
      (f (apply g args))))

  ;; ((fn [& args]
  ;;     (not (apply = args))) 1 2 3)

  ;; (print ((fn [& args]
  ;;           (print args)
  ;;           (apply = args)) 2 2))

  ;; (defn complement [predicate]
  ;;   :doc "Returns the logical complement of a predicate."
  ;;   (compose not predicate))

  ;; REDUCERS AND TRANSDUCERS

  ;; PREDICATES

  (defn nil? [value]
    (is nil value))

  (defn zero? [value]
    (= 0 value))

  (defn complement [predicate]
    (fn [& args] (not (apply predicate args))))

  (defn not= [a b]
    (not (= a b)))

  (defn empty? [coll]
    (= 0 (count coll)))

  (defn even? [n]
    (= (% 2 n) 0))

  (defn odd? [n]
    (= (% 2 n) 1))

  (defn pos? [n]
    (< 0 n))

  (defn neg? [n]
    (< n 0))

  ; or and and implemented as macros

  (defmacro or [& clauses]
    ;; or is the disjunction operator
    ;; the empty disjunction is false by convention
    (cond (is-empty clauses) false
          (= 1 (count clauses)) (first clauses)
          true `(do (def cl ~(first clauses))
                    (if cl cl (or ~@(rest clauses))))))

  ;; (defmacro and [& clauses]
  ;;   ;; by convention the empty conjuntion is true
  ;;   (sexp))

  ;; SEQUENCES

  (defn map [f coll]
    :doc "Maps a function over a collection eagerly. It would be nice if it could be lazy.
          Calls seq on its coll.
          Also there is the possibility of making it a transducer."
    (let [s (seq coll)]
      (when s
        (cons (f (first s)) (map f (rest s))))))

  (defn filter [pred coll]
    :doc "Filters over a collection eagerly. Calls seq on its argument."
    (let [s (seq coll)]
      (when s
        (let [f (first s)
              r (rest s)]
          (if (pred f)
            (cons f (filter pred r))
            (filter pred r))))))

  ;; (defn take)

  (comment
    ;; a way of making a mapping transducer
    ([f]
     (fn [rf]
       (fn
         ([] (rf))
         ([result] (rf result))
         ([result input]
          (rf result (f input)))
         ([result input & inputs]
          (rf result (apply f input inputs)))))))

  ;; (defn reduce [f coll initial])

  ;; (defn odds [])
  ;; (defn evens [seq]
  ;;   ;; from a sequence, returns a sequence containing all of its elements with pair indexes
  ;;   ;; without losing order
  ;;   (def new-seq (empty seq))
  ;;   (when seq
  ;;     (append (first seq) new-seq)))


  (defmacro -> [x & forms]
    (if forms
      (let [form (first forms)
            threaded (if (seq? form)
                       `(~(first form) ~x ~@(next form))
                       (sexp form x))]
        (-> threaded (next forms)))
      x))
  
  ;; METAPROGRAMMING

  (defmacro pme [expr]
    ;; stands for 'print-macro-expansion'
    `(print
      (macroexpand ~expr)))

  ;; TESTING
  ;; the test library is baked into the base library, because it is so lightweight and performance is not a huge concern

  (def *tests-have-failed* false)

  (defn single-test [name test result]
    (when (not (= test result))
      (def *tests-have-failed* true)
      (prn "❗️ Test failed: `" name "` was expected to be " result " but got " test " instead. \n")))

  (defmacro test [& tests]
    (if (instance? (first tests) str)
      `(do (def *section-name* ~(first tests))
           ~(when (rest tests)
              `(test ~@(rest tests))))
      `(do
         (single-test *section-name* ~(first tests) ~(second tests))
         ~(when (rrest tests)
            `(test ~@(rrest tests))))))

  (defmacro tests [name & tests]
    `(do
       (def *section-name* ~name)
       (prn "ℹ️ Testing `" ~name "`\n")
       (test ~@tests)
       (if *tests-have-failed*
         (prn "❌ Tests completed with some failures. \n")
         (prn "✅ Tests completed without failures. \n"))))

  (defmacro time [& forms]
    `(do (def t (date))
         ~@forms
         (- (date) t)))

  (defmacro pmt [& forms]
    `(print (measure-time ~@forms)))

  (comment "Various comments about the base library."

           "I have name resolution bugs, sometimes if a symbol is not found the interpreter will go into an infinite loop instead. Also, there are bugs when I try to namespace-qualify the symbols: it simply doesn't work."

           (defmacro do [& expressions]
             :doc "Serves as an example to show that `do` is easily defined in terms of only function application.
          However for practical purposes `do` is included as a special form in the interpeter."
             `((fn []
                 ~@expressions)))))
