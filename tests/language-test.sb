(ns language-test
  (include base)
  :doc "Tests for the built-in language features, such as closures"
  :date-created "3 February 2022"
  :author "Jérémie Vaney"
;;   :include [base]

  (tests "Built-in language features"

    "if"
    (if true nil) nil
    (if false true false) false
    (cond
      false "yes"
      false "no"
      true "default") "default"
    (cond
      false "yes"
      true "no"
      true "default") "no"
    ;; (if something :then
    ;;     (do this)
    ;;  :else
    ;;     (do that))


    "def"
    (try
      (def)
      :catch "exception") "exception"
    (try
      (def zzz)
      :catch "exception") "exception"
    ;;   a def returns nil
    (def a 3) nil
      ;; a definiton binds a symbol to its evaluated expression
    (do
      (def b (+ 5 (- 10 5)))
      b) 10
      ;; a definition can bind multiple elements at once, if they are in a vector
    (def [c 1 d 2]) nil
    (do
      (def [e 10 f 30])
      (+ e f)) 40
    (do (def [g (+ 50 (* 34 70))
              h (- g 430)])
        (append h (append g []))) [2430 2000]
      ;; TODO add cases that should throw errors


    "closures"
      ;; calling an empty function - should return nil
    ((fn [])) nil
    ((fn [] ())) nil
    (do) nil
      ;; ((fn [a b c] nil)) nil ;; TODO: add a nice error message and an error system for the language

      ;; definitions made inside a closure should not be visible from an outer scope
    ((fn []
       (def a 60)
       a)) 60

    "MultiMethods"
    ((fn [a b c] (+ a b c)) 1 2 3) 6
    (def h (fn
             ([] 0)
             ([a b] 2)
             ([c d e] 3))) nil
    (h) 0
    ;; (h 1) 0
    (try (h 1)
         :catch "error") "error"
    (h 1 2) 2
    (h 0 0 0) 3

    "equality"
    (= 1 1) true
    (= nil nil) true
    (= true true) true
    (= false false) true
    (= true false) false
    (= nil true) false
    (= nil false) false
    (= nil 0) false
    {:one 1
     :meta 'this
     :code '(sexp object)}
    {"one" 1
     "meta" 'this
     "code" '(sexp object)}

    "identity"
    (is nil nil) true
    (is true true) true
    (is false false) true
    (is true false) false
    (is nil false) false

    "booleans"
    ;;   (and true true true) true
    ;;   (and true true false) false
    (and false true) false
    (and false false) false
      ;; other arities

    ;;   (or true true) true
    ;;   (or true false) true
    ;;   (or false true) true
    ;;   (or false false) false

      ;; nand 
      ;; xor

    "arithmetic"
    (+ 34 6) 40
    (- 34 34) 0
    (- 34) -34
    (- 0 34) -34
    (* 3 4 5 4) 240
    (% 2 3) 1
    (% 65 213432) 37
    (- 32423 5345 (* 324 32 (+ 323 2 23) 432 3 4234)) -19798399669818

    "=INTEROP="
    "dot form"
    '(.inc this) '(get-attr "inc" this))
      ;;  (do
      ;;    ((fn []
      ;;       (def b 60)
      ;;       b))
      ;;    b) ;; catch unresolved symbol error
      ;;  (do
      ;;    (do (def c "text"))
      ;;    c) nil ;; catch unresolved symbol error
       ;; calling with the wrong amount of arguments throws an error

  ;; TODO address the symbol resolution bugs
  ;;


;;   (tests "sequence functions"
;;     (test "first"
;;       (first '(1 2) 1)
;;       (first [3 4] 3)
;;       (first []) nil))

;; BUG
;;   (defmacro m [arg]
;;     (def p (eval ~arg))
;;     (+ 2 p))
;;   (pme (m (* 4 6)))


  (defn add3 [x] (+ x 3))
;;   (print (filter is-odd [1 2 3 23 4324 345 354]))


;;   (tests "sequence functions"
;;     (test "map"
;;       (map (fn [n] (+ n 10)) [0 1 2 3 4 5]) [10 11 12 13 14 15])

;;     (test "filter"
;;       (filter is-odd [1 2 3 23 4324 345 354]) [1 3 23 345]))

  (tests "combinators"

    "apply"
    (apply add3 [3]) 6
    (apply not [true]) false
    (apply + 1 2 3 [23 234 23 53]) 339

    "compose"
    ;; ((compose not =) true true) false 
    )

;;   (print ((compose compose compose) not =))

;;   (def zeta 3)

;;   (print (try "hello" zeta))

;;   (throw (exception "Hello"))

;;   (py! "a = 2 + 3")

;;   (print (try "This value"
;;               "This other value"
;;               :catch "There was an exception"
;;               :finally "Some expr that is not returned"))

;;   (tests "keyword arguments"

;;     "Function metadata"
;;     (do (pme (defn my-func []
;;           :doc "documentation"
;;           (* 1 2)))
;;         (print (get-attr "meta" my-func)))
;;     0)

;;   (tests "metadata"
;;     (get (fn []
;;       :meta 1
;;       "return-value")) 1)

  (tests "try-catch-finally"

    "`try` with no `catch`"
    (try) nil
    (try nil) nil
    (try "hello") "hello"

    "try expressions"
    (try
      "string"
      :catch "something else") "string"
    (try
      :catch "error") nil
    (try
      :catch "error"
      :finally "cleanup") nil
    (try
      something ; `something` is not defined
      :catch "There was an exception"
      :finally "Doin' the cleanup") "There was an exception"
    (try something true
         :catch false) false
    (try
      "first thing"
      (* 3 4)
      :catch 5) 12)


  (tests "interoperability"
    "eval"
    1 1

    "exec"
    1 1

    "accessing built-in objects such as functions"
    (py/len [1 2 3]) 3
    (py/abs -300) 300
    (type (py/float 1)) py/float
    (py/eval "1 + 2") 3

    "calling methods on objects"
    (do
      (def a [])
      (.append 3 a)
      a) [3]
    (do (def c [3 4 45 3 23 1])
        (.sort c)
        c) [1 3 3 4 23 45])
  
  (tests "metaprogramming"

    ;; ::passing
    "sexp equality testing"
    '() (sexp) ; both methods are equivalent

    "quoting"
    '() (quote ())

    "quasiquoting and its expansion"
    `(1 2 3) (quote (1 2 3))
    `(1 2 3 ~(+ 2 2)) '(1 2 3 4)
    `(1 2 3 ~@[1 2 3]) '(1 2 3 1 2 3)

    "compatibility of quasiquoting with named parameters"
    `(1 2 3 :named 2) '(1 2 3 :named 2)
    `(1 2 3 ~@(sexp :named "value")) '(1 2 3 4 :named "value")

    "named parameters in vectors"
    [:named 3 :other 3] [:named 3 :other 3]

    ;; ::failing
    ;; '() (sexp 1)
    ;; `(1 2 3 :named 2) '(1 2 3 :named 4)

    ;; (prepend-sexp '(hello this :something val) '(:something value))
    ;; (:name) -> throws
    ))