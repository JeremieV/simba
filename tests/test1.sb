; === Control flow

if. (lt. x 5)
    print. "true"
    "false"

; parenthesis omitted, `lt` should apply to the rest of the form.
if. (lt. x 5)
    print. "true"
    "false"

cond. x
  (eq. x 0) 'zero'
  (eq. x 1) 'one'
  _         'not zero or one'

; === Functions

def. fibonacci [n]
  cond.
    (eq. n 0) 0
    (eq. n 1) 1
    "else"    add. (fibonacci. sub. n 1) (fibonacci. sub. n 2)

def. fact
    lambda. [n] if. (eq. n 0) 1
                    mult. n fact. sub. n 1

; Closures

; Recursion

; === Polymorphism

; 1. Multimethods

defmulti.  encounter fn. [x y] [(:Species x) (:Species y)]
defmethod. encounter [:Bunny :Lion] [b l]    :run-away
defmethod. encounter [:Lion :Bunny] [l b]    :eat
defmethod. encounter [:Lion :Lion] [l1 l2]   :fight
defmethod. encounter [:Bunny :Bunny] [b1 b2] :mate

; 2. Protocols
; A protocol is a named set of named methods and their signatures, defined using defprotocol (see clojure protocols)

defprotocol. P
  foo. [x]
  bar-me. [x] [x y]

deftype. Foo [a b c]
  P
  foo.    [x] a
  bar-me. [x] b
  bar-me. [x y] (+ c y)

; === Side effects

print. fibonacci. 34