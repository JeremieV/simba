(ns base
  ;; Collection of functions and macros to be included by default with the Simba language.
  ;; Date created: 27 January 2021
  ;; Author: Jérémie Vaney

  ;; CONTROL FLOW

  (def defn
    (macro [name args & expr]
           `(def ~name
              (fn ~args ~@expr))))

  (def defmacro
    (macro [name args & expr]
           `(def ~name
              (macro ~args ~@expr))))

  (defmacro when [condition & clauses]
    `(if ~condition
       (do ~@clauses)
       nil))

  (defmacro cond [& clauses]
    (when clauses
      (sexp 'if (first clauses)
            (if (rest clauses)
              (second clauses)
              (print "error cond"))
            (prepend-sexp 'base/cond (rest (rest clauses))))))

  ;; COMBINATORS

  (defmacro apply* [f args]
    ;; apply needs to work better. here works in very restricted situations
    `(f ~@args))

  (defn apply [f args]
    (print args)
    (apply* f args))

  (comment
    "Different ways to implement apply:"
    "As it currently is the apply* macro does not evaluate its arguments so it is insufficient"
    "Another thing we would like is to have apply be variadic like in clojure.")

  ;; PREDICATES

  (defn not= [a b]
    (not (= a b)))

  (defn is-empty [coll]
    (= 0 (count coll)))

  ; or and and implemented as macros

  (defmacro or [& clauses]
    ;; or is the disjunction operator
    ;; the empty disjunction is false by convention
    (cond (is-empty clauses) false
          (= 1 (count clauses)) (first clauses)
          true `(do (def cl ~(first clauses))
                    (if cl cl (or ~@(rest clauses))))))

  ;; (defmacro and [& clauses]
  ;;   ;; by convention the empty conjuntion is true
  ;;   (sexp))

  ;; SEQUENCES

  (defn first [seq]
    (nth 0 seq))

  (defn rest [seq]
    (slice 1 nil seq))

  (defn rrest [seq]
    (rest (rest seq)))

  (defn second [seq]
    (first (rest seq)))

  ;; (defmacro cond [fcond then & else]
  ;;   `(if fcond
  ;;      then
  ;;      (if (first else))))

  ;; (defn complement [predicate]
  ;;   (fn [& args] (not (apply predicate args))))

  (defn complement [predicate]
    ;; increases orthogonality of the language as described in "On Lisp"~ by Paul Graham
    (compose not predicate))

  ;; METAPROGRAMMING

  (defmacro pme [expr]
    ;; stands for 'print-macro-expansion'
    `(print 
      (macroexpand ~expr)))

  
 ;;
  )