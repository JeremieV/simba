;   Copyright (c) Rich Hickey. All rights reserved.
;   The use and distribution terms for this software are covered by the
;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;   which can be found in the file epl-v10.html at the root of this distribution.
;   By using this software in any fashion, you are agreeing to be bound by
;   the terms of this license.
;   You must not remove this notice, or any other, from this software.

(ns ^{:doc "Collection of functions and macros to be included by default with the Simba language."
      :date-created "27 January 2022"
      :author "Jérémie Vaney"}
 base)

;; Simba specific 

;; IMPORTS -- temporary

(def py (py-exec "import builtins;builtins"))

(def operator (py-exec "import operator;operator"))
(def simba.lang.RT (py-exec "import simba.lang.RT;simba.lang.RT"))
(def simba.lang.types (py-exec "import simba.lang.types;simba.lang.types"))
(def simba.lang.interfaces (py-exec "import simba.lang.interfaces;simba.lang.interfaces"))
(def simba.lang.PersistentList (py-exec "import simba.lang.PersistentList;simba.lang.PersistentList"))
(def simba.exceptions (py-exec "import simba.exceptions;simba.exceptions"))

;; to fix
(def set! (fn [] (.__setattr__ obj attr value)))
(def IllegalArgumentException simba.exceptions/IllegalArgumentException)

;; simba specific end

;; CONTROL FLOW

(def
  ^{:arglists '([& items])
    :doc "Creates a new list containing the items."
    :added "1.0"}
  list simba.lang.PersistentList/creator)

(def
  ^{:arglists '([x seq])
    :doc "Returns a new seq where x is the first element and seq is
    the rest."
    :added "1.0"
    :static true}
  cons (fn ^:static cons [x seq] (. simba.lang.RT (cons x seq))))

;; (def ^{:doc "Shorthand for defining functions."
;;        :macro true}
;;   defn
;;   (fn [&form &env name & body]
;;     `(def ~name
;;        (fn ~@body))))

;; (defmacro
;;   ^{:doc "Returns true if the variable has a binding in the current environment, else false."}
;;   is-assigned?
;;   [var]
;;   `(try (do ~var true)
;;         (catch false)))

;; (defmacro ^{:doc "Defines a function."}
;;   defn
;;   [name & body]
;;   `(if (is-assigned? ~name)
;;      (.register (fn ~@body) ~name)
;;      (def ~name (fn ~@body))))

;; (defmacro with [resource & exprs]
;;   `(let ~resource
;;      ~@exprs
;;      (.close ~(first resource))))

;; (defmacro ^{:doc "Shorthand to return a value after defining it.
;;         Analog of the Python 'walrus' operator."}
;;   assign
;;   [name value]
;;   `(do (def ~name ~value) ~name))

;; (def ^{:doc "Like require, but imports a Python module instead."
;;        :macro true}
;;   import
;;   (fn [&form &env module-name]
;;     `(def ~module-name
;;        (py-exec ~(+ "import " (py/str module-name) "; " (py/str module-name))))))

;; (defmacro new [obj & args]
;;   (obj ~@args))

(def
  ^{:arglists '([coll])
    :doc "Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil."
    :added "1.0"
    :static true}
  first (fn ^:static first [coll] (. simba.lang.RT (first coll))))

(def
  ^{:arglists '([coll])
    :tag simba.lang.ISeq
    :doc "Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil."
    :added "1.0"
    :static true}
  next (fn ^:static next [x] (. simba.lang.RT (next x))))

(def
  ^{:arglists '([coll])
    :tag simba.lang.ISeq
    :doc "Returns a possibly empty seq of the items after the first. Calls seq on its
  argument."
    :added "1.0"
    :static true}
  rest (fn ^:static rest [x] (. simba.lang.RT (more x))))

(def
  ^{:arglists '([] [coll] [coll x] [coll x & xs])
    :doc "conj[oin]. Returns a new collection with the xs
    'added'. (conj nil item) returns (item).
    (conj coll) returns coll. (conj) returns [].
    The 'addition' may happen at different 'places' depending
    on the concrete type."
    :added "1.0"
    :static true}
  conj (fn ^:static conj
         ([] [])
         ([coll] coll)
         ([coll x] (simba.lang.RT/conj coll x))
         ([coll x & xs]
          (if xs
            (recur (simba.lang.RT/conj coll x) (first xs) (next xs))
            (simba.lang.RT/conj coll x)))))

(def
  ^{:doc "Same as (first (next x))"
    :arglists '([x])
    :added "1.0"
    :static true}
  second (fn ^:static second [x] (first (next x))))

(def
  ^{:doc "Same as (first (first x))"
    :arglists '([x])
    :added "1.0"
    :static true}
  ffirst (fn ^:static ffirst [x] (first (first x))))

(def
  ^{:doc "Same as (next (first x))"
    :arglists '([x])
    :added "1.0"
    :static true}
  nfirst (fn ^:static nfirst [x] (next (first x))))

(def
  ^{:doc "Same as (first (next x))"
    :arglists '([x])
    :added "1.0"
    :static true}
  fnext (fn ^:static fnext [x] (first (next x))))

(def
  ^{:doc "Same as (next (next x))"
    :arglists '([x])
    :added "1.0"
    :static true}
  nnext (fn ^:static nnext [x] (next (next x))))

(def
  ^{:arglists '([coll])
    :doc "Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object."
    :tag simba.lang.ISeq
    :added "1.0"
    :static true}
  seq (fn ^:static seq [coll] (. simba.lang.RT (seq coll))))

(def
  ^{:arglists '([^Class c x])
    :doc "Evaluates x and tests if it is an instance of the class
    c. Returns true or false"
    :added "1.0"}
  instance? (fn instance? [^Class c x] (py/isinstance x c)))

(def
  ^{:arglists '([x])
    :doc "Return true if x implements ISeq"
    :added "1.0"
    :static true}
  seq? (fn ^:static seq? [x] (instance? simba.lang.interfaces/ISeq x)))

(def String py/str)

(def
  ^{:arglists '([x])
    :doc "Return true if x is a String"
    :added "1.0"
    :static true}
  string? (fn ^:static string? [x] (instance? String x)))

(def
  ^{:arglists '([x])
    :doc "Return true if x implements IPersistentMap"
    :added "1.0"
    :static true}
  map? (fn ^:static map? [x] (instance? simba.lang.types/PersistentMap x)))

(def
  ^{:arglists '([x])
    :doc "Return true if x implements IPersistentVector"
    :added "1.0"
    :static true}
  vector? (fn ^:static vector? [x] (instance? simba.lang.types/PersistentVector x)))

(def
  ^{:arglists '([map key val] [map key val & kvs])
    :doc "assoc[iate]. When applied to a map, returns a new map of the
    same (hashed/sorted) type, that contains the mapping of key(s) to
    val(s). When applied to a vector, returns a new vector that
    contains val at index. Note - index must be <= (count vector)."
    :added "1.0"
    :static true}
  assoc
  (fn ^:static assoc
    ([map key val] (simba.lang.RT/assoc map key val))
    ([map key val & kvs]
     (let [ret (simba.lang.RT/assoc map key val)]
       (if kvs
         (if (next kvs)
           (recur ret (first kvs) (second kvs) (nnext kvs))
           (throw (IllegalArgumentException.
                   "assoc expects even number of arguments after map/vector, found odd number")))
         ret)))))

;; METADATA

;; (defn
;;   ^{:arglists '([obj])
;;     :doc "Returns the metadata of obj, returns nil if there is no metadata."
;;     :added "1.0"
;;     :static true}
;;   meta [x]
;;   (if (py/hasattr x "meta")
;;     (.meta x)))

(def
  ^{:arglists '([obj])
    :doc "Returns the metadata of obj, returns nil if there is no metadata."
    :added "1.0"
    :static true}
  meta (fn ^:static meta [x]
         (if (instance? simba.lang.interfaces/IMeta x)
           (. ^simba.lang.interfaces/IMeta x (meta)))))

(def
  ^{:arglists '([obj m])
    :doc "Returns an object of the same type and value as obj, with
    map m as its metadata."
    :added "1.0"
    :static true}
  with-meta (fn [x m]
              (.withMeta x m)))

(def ^{:private true :dynamic true}
  assert-valid-fdecl (fn [fdecl]))

;; (def
;;   ^{:private true}
;;   sigs
;;   (fn [fdecl]
;;     (assert-valid-fdecl fdecl)
;;     (let [asig
;;           (fn [fdecl]
;;             (let [arglist (first fdecl)
;;                  ;elide implicit macro args
;;                   arglist (if (simba.lang.Util/equals '&form (first arglist))
;;                             (simba.lang.RT/subvec arglist 2 (simba.lang.RT/count arglist))
;;                             arglist)
;;                   body (next fdecl)]
;;               (if (map? (first body))
;;                 (if (next body)
;;                   (with-meta arglist (conj (if (meta arglist) (meta arglist) {}) (first body)))
;;                   arglist)
;;                 arglist)))
;;           resolve-tag (fn [argvec]
;;                         (let [m (meta argvec)
;;                               ^simba.types.Symbol tag (:tag m)]
;;                           (if (instance? simba.types.Symbol tag)
;;                             (if (simba.lang.Util/equiv (.indexOf (.getName tag) ".") -1)
;;                               (if (simba.lang.Util/equals nil (simba.lang.Compiler$HostExpr/maybeSpecialTag tag))
;;                                 (let [c (simba.lang.Compiler$HostExpr/maybeClass tag false)]
;;                                   (if c
;;                                     (with-meta argvec (assoc m :tag (simba.lang.Symbol/intern (.getName c))))
;;                                     argvec))
;;                                 argvec)
;;                               argvec)
;;                             argvec)))]
;;       (if (seq? (first fdecl))
;;         (loop [ret [] fdecls fdecl]
;;           (if fdecls
;;             (recur (conj ret (resolve-tag (asig (first fdecls)))) (next fdecls))
;;             (seq ret)))
;;         (list (resolve-tag (asig fdecl)))))))

(def
  ^{:arglists '([coll])
    :doc "Return the last item in coll, in linear time"
    :added "1.0"
    :static true}
  last (fn ^:static last [s]
         (if (next s)
           (recur (next s))
           (first s))))

(def
  ^{:arglists '([coll])
    :doc "Return a seq of all but the last item in coll, in linear time"
    :added "1.0"
    :static true}
  butlast (fn ^:static butlast [s]
            (loop [ret [] s s]
              (if (next s)
                (recur (conj ret (first s)) (next s))
                (seq ret)))))

(def
  ^{:doc "Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions."
    :arglists '([name doc-string? attr-map? [params*] prepost-map? body]
                [name doc-string? attr-map? ([params*] prepost-map? body) + attr-map?])
    :added "1.0"
    :macro true}
  defn (fn defn [&form &env name & fdecl]
        ;; Note: Cannot delegate this check to def because of the call to (with-meta name ..)
         (if (instance? simba.lang.types/Symbol name)
           nil
           (throw (IllegalArgumentException. "First argument to defn must be a symbol")))
         (let [m (if (string? (first fdecl))
                   {:doc (first fdecl)}
                   {})
               fdecl (if (string? (first fdecl))
                       (next fdecl)
                       fdecl)
               m (if (map? (first fdecl))
                   (conj m (first fdecl))
                   m)
               fdecl (if (map? (first fdecl))
                       (next fdecl)
                       fdecl)
               fdecl (if (vector? (first fdecl))
                       (list fdecl)
                       fdecl)
               m (if (map? (last fdecl))
                   (conj m (last fdecl))
                   m)
               fdecl (if (map? (last fdecl))
                       (butlast fdecl)
                       fdecl)
              ;;  m (conj {:arglists (list 'quote (sigs fdecl))} m)
              ;;  m (let [inline (:inline m)
              ;;          ifn (first inline)
              ;;          iname (second inline)]
              ;;     ;; same as: (if (and (= 'fn ifn) (not (symbol? iname))) ...)
              ;;      (if (if (simba.lang.Util/equiv 'fn ifn)
              ;;            (if (instance? simba.lang.Symbol iname) false true))
              ;;       ;; inserts the same fn name to the inline fn if it does not have one
              ;;        (assoc m :inline (cons ifn (cons (simba.lang.Symbol/intern (.concat (.getName ^simba.lang.Symbol name) "__inliner"))
              ;;                                         (next inline))))
              ;;        m))
               m (conj (if (meta name) (meta name) {}) m)]
           (list 'def (with-meta name m)
                ;;todo - restore propagation of fn name
                ;;must figure out how to convey primitive hints to self calls first
								;;(cons `fn fdecl)
                 (with-meta (cons `fn fdecl) {:rettag (:tag m)})))))

(defn vector
  "Creates a new vector containing the args."
  {:added "1.0"
   :static true}
  ([] [])
  ([a] [a])
  ([a b] [a b])
  ([a b c] [a b c])
  ([a b c d] [a b c d])
  ([a b c d e] [a b c d e])
  ([a b c d e f] [a b c d e f])
  ([a b c d e f & args]
   ((. simba.lang.types/PersistentVector create) (cons a (cons b (cons c (cons d (cons e (cons f args)))))))))

(defn vec
  "Creates a new vector containing the contents of coll."
  {:added "1.0"
   :static true}
  ([coll]
  ;;  (if (vector? coll)
  ;;    (if (instance? simba.lang.interfaces.IObj coll)
  ;;      (with-meta coll nil)
  ;;      ((. simba.lang.types/PersistentVector create) coll)))
   ((. simba.lang.types/PersistentVector create) coll)))

(defn hash-map
  "keyval => key val
  Returns a new hash map with supplied mappings.  If any keys are
  equal, they are handled as if by repeated uses of assoc."
  {:added "1.0"
   :static true}
  ([] {})
  ([& keyvals]
   (simba.lang.types/createMapFromSeq keyvals)))

(defn nil?
  "Returns true if x is nil, false otherwise."
  {:tag Boolean
   :added "1.0"
   :static true}
   ;:inline (fn [x] (list 'simba.lang.Util/identical x nil))
  [x] (operator/is_ x nil))

(def
  ^{:doc "Like defn, but the resulting function name is declared as a
    macro and will be used as a macro by the compiler when it is
    called."
    :arglists '([name doc-string? attr-map? [params*] body]
                [name doc-string? attr-map? ([params*] body) + attr-map?])
    :added "1.0"
    :macro true}
  defmacro (fn [&form &env
                name & args]
             (let [prefix (loop [p (list name) args args]
                            (let [f (first args)]
                              (if (string? f)
                                (recur (cons f p) (next args))
                                (if (map? f)
                                  (recur (cons f p) (next args))
                                  p))))
                   fdecl (loop [fd args]
                           (if (string? (first fd))
                             (recur (next fd))
                             (if (map? (first fd))
                               (recur (next fd))
                               fd)))
                   fdecl (if (vector? (first fdecl))
                           (list fdecl)
                           fdecl)
                   add-implicit-args (fn [fd]
                                       (let [args (first fd)]
                                         (cons (vec (cons '&form (cons '&env args))) (next fd))))
                   add-args (fn [acc ds]
                              (if (nil? ds)
                                acc
                                (let [d (first ds)]
                                  (if (map? d)
                                    (conj acc d)
                                    (recur (conj acc (add-implicit-args d)) (next ds))))))
                   fdecl (seq (add-args [] fdecl))
                   decl (loop [p prefix d fdecl]
                          (if p
                            (recur (next p) (cons (first p) d))
                            d))]
               (list 'do
                     (cons `defn decl)
                     (list '. (list 'var name) '(setMacro))
                     (list 'var name)))))

(defmacro when
  "Evaluates test. If logical true, evaluates body in an implicit do."
  {:added "1.0"}
  [test & body]
  (list 'if test (cons 'do body)))

(defmacro when-not
  "Evaluates test. If logical false, evaluates body in an implicit do."
  {:added "1.0"}
  [test & body]
  (list 'if test nil (cons 'do body)))

(defn false?
  "Returns true if x is the value false, false otherwise."
  {:tag Boolean,
   :added "1.0"
   :static true}
  [x] (operator/is_ x false))

(defn true?
  "Returns true if x is the value true, false otherwise."
  {:tag Boolean,
   :added "1.0"
   :static true}
  [x] (operator/is_ x true))

(defn boolean?
  "Return true if x is a Boolean"
  {:added "1.9"}
  [x] (instance? py/bool x))

(defn not
  "Returns true if x is logical false, false otherwise."
  {:tag Boolean
   :added "1.0"
   :static true}
  [x] (if x false true))

(defn some?
  "Returns true if x is not nil, false otherwise."
  {:tag Boolean
   :added "1.6"
   :static true}
  [x] (not (nil? x)))

(defn any?
  "Returns true given any argument."
  {:tag Boolean
   :added "1.9"}
  [x] true)

(defn str
  "With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args."
  {:tag String
   :added "1.0"
   :static true}
  ([] "")
  ([^Object x]
   (if (nil? x) "" (py/str x)))
  ;; (^String [x & ys]
  ;;  ((fn [^StringBuilder sb more]
  ;;     (if more
  ;;       (recur (. sb  (append (str (first more)))) (next more))
  ;;       (str sb)))
  ;;   (new StringBuilder (str x)) ys))
  )

(defn symbol?
  "Return true if x is a Symbol"
  {:added "1.0"
   :static true}
  [x] (instance? simba.lang.types/Symbol x))

(defn keyword?
  "Return true if x is a Keyword"
  {:added "1.0"
   :static true}
  [x] (instance? simba.lang.types/Keyword x))

(defmacro cond
  "Takes a set of test/expr pairs. It evaluates each test one at a
  time.  If a test returns logical true, cond evaluates and returns
  the value of the corresponding expr and doesn't evaluate any of the
  other tests or exprs. (cond) returns nil."
  {:added "1.0"}
  [& clauses]
  (when clauses
    (list 'if (first clauses)
          (if (next clauses)
            (second clauses)
            (throw (IllegalArgumentException.
                    "cond requires an even number of forms")))
          (cons 'simba.core/cond (next (next clauses))))))

(defn symbol
  "Returns a Symbol with the given namespace and name. Arity-1 works
  on strings, keywords, and vars."
  {:tag simba.lang.Symbol
   :added "1.0"
   :static true}
  ([name]
   (cond
     (symbol? name) name
     (instance? String name) (. simba.lang.types/Symbol intern name)
     (instance? simba.lang.types/Var name) (.toSymbol name)
     (instance? simba.lang.types/Keyword name) (.sym name)
     :else (throw (IllegalArgumentException. "no conversion to symbol"))))
  ([ns name] ((. simba.lang.types/Symbol intern) ns name)))

;; ;; MULTIMETHODS

;; (defmacro defmulti [name dispatch-fn]
;;   `(def ~name (py/MultiFn ~(py/str name) ~dispatch-fn)))

;; (defmacro defmethod [multi dispatch-val & body]
;;   `(.register ~multi (fn ~@body) ~dispatch-val))

;; ;; ---

;; (defmacro ^{:doc "Used to assert that certain macros are called correctly."
;;             :private true}
;;   assert-args
;;   [& pairs]
;;   `(do (when-not ~(first pairs)
;;          (throw (py/IllegalArgumentException
;;                  (py/str (first ~'&form) " requires " ~(second pairs) " in " ~'*ns* ":" (:line (meta ~'&form))))))
;;        ~(let [more (nnext pairs)]
;;           (when more
;;             (vector `assert-args more)))))

;; (defn inc [n]
;;   (+ n 1))

;; (defn dec [n]
;;   (- n 1))

;; ;; ;; TYPES

;; (defn list? [x]
;;   (instance? x simba.lang.PersistentList/PersistentList))

;; ;; ;; SEQUENCES

;; (def seq simba.lang.RT/sb_seq)

;; (def freeze py/p.freeze)
;; (def thaw py/p.thaw)

;; (defn ^{:doc "Returns an empty sequence of the type of s."} 
;;   empty
;;   [s]
;;   (cond
;;     (vector? s) []
;;     (map? s) {}
;;     true ((type s))))

;; (defn rest [s]
;;   (if (seq s)
;;     (between 1 nil s)
;;     (empty s)))

;; (defn rrest [s]
;;   (rest (rest s)))

;; (defn next [s]
;;   :doc "next is like rest except that it returns nil on an empty seq"
;;   (if (seq s)
;;     (between 1 nil s)
;;     nil))

;; (defn nnext [s]
;;   (next (next s)))

;; (defn second [s]
;;   (first (rest s)))

;; (defn take [n s]
;;   (between 0 n s))

;; (defn take-last [n s]
;;   (between (- n) nil s))


;; ;; ;; COMBINATORS

;; (def ^{:doc "Function application. Returns the result of applying f to the last argument, which has to be a sequence. Any arguments before the last are prepended to the sequence."
;;        :signature '[f & args]}
;;   apply
;;   simba.lang.RT/sb_apply)

;; (defn ^{:doc "Returns its argument."} 
;;   identity [x]
;;   x)

;; (def thrush (fn [a b] (b a)))

;; (defn ^{:doc "An extended version of the bluebird combinator."}
;;   compose
;;   ([] identity)
;;   ([f] f)
;;   ([f g] (fn [& args]
;;            (f (apply g args)))))

;; (defn ^{:doc "Takes a function with fewer args than normal, and returns a function that takes a variable amount of additional args. When called, the returned function calls f with args + additional args."}
;;   partial
;;   ([f] f)
;;   ([f & args] (fn [& more-args]
;;                 (apply f (concat args more-args)))))

;; ;; ;; REDUCERS AND TRANSDUCERS

;; ;; ;; PREDICATES

;; (defn nil? [value]
;;   (is nil value))

;; (defn zero? [value]
;;   (= 0 value))

;; (defn ^{:alternative-implementation '(compose not predicate)} 
;;   complement [predicate]
;;   (fn [& args] (not (apply predicate args))))

;; (defn not= [a b]
;;   (not (= a b)))

;; (defn empty? [coll]
;;   (= 0 (count coll)))

;; (defn even? [n]
;;   (= (% 2 n) 0))

;; (defn odd? [n]
;;   (= (% 2 n) 1))

;; (defn pos? [n]
;;   (< 0 n))

;; (defn neg? [n]
;;   (< n 0))

;;;;;;;;;;;;;;;;at this point all the support for syntax-quote exists;;;;;;;;;;;;;;;;;;;;;;

(defmacro if-not
  "Evaluates test. If logical false, evaluates and returns then expr, 
  otherwise else expr, if supplied, else nil."
  {:added "1.0"}
  ([test then] `(if-not ~test ~then nil))
  ([test then else]
   `(if (not ~test) ~then ~else)))

(defn identical?
  "Tests if 2 arguments are the same object"
  {:inline (fn [x y] `(. clojure.lang.Util identical ~x ~y))
   ;:inline-arities #{2}
   :added "1.0"}
  ([x y] (operator/is_ x y)))

(defmacro and
  "Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn't evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true."
  {:added "1.0"}
  ([] true)
  ([x] x)
  ([x & next]
  ;; very mysterious bug
  ;;  `(let [and# ~x]
  ;;     (if and# (and ~@next) and#))
   `(if ~x (and ~@next) ~x)))

(defmacro or
  "Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn't
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil."
  {:added "1.0"}
  ([] nil)
  ([x] x)
  ([x & next]
  ;;  `(let [or# ~x]
  ;;     (if or# or# (or ~@next)))
   `(if ~x ~x (or ~@next))))

;; ;; ;; SEQUENCES

;; (defn ^{:doc "Maps a function over a collection eagerly. It would be nice if it could be lazy.
;;           Calls seq on its coll.
;;           Also there is the possibility of making it a transducer."} 
;;   map [f coll]
;;   (let [s (seq coll)]
;;     (when s
;;       (cons (f (first s)) (map f (rest s))))))

;; (defn ^{:doc "Filters over a collection eagerly. Calls seq on its argument."} 
;;   filter [pred coll]
;;   (let [s (seq coll)]
;;     (when s
;;       (let [f (first s)
;;             r (rest s)]
;;         (if (pred f)
;;           (cons f (filter pred r))
;;           (filter pred r))))))

;; ;; (defn reduce [] nil)
;; ;; ;; (defn reduce [f coll initial])

;; ;; ;; (defn take)

;; ;; ;; (defn partition)

;; (defn ^{:doc "Removes the items that satisfy the predicate in coll"} 
;;   remove [pred coll]
;;   (filter (complement pred) coll))

(defn boolean
  "Coerce to boolean"
  {;:inline (fn  [x] `(. clojure.lang.RT (booleanCast ~x)))
   :added "1.0"}
  [x] (if x true false))

;; (defmacro ..
;;   "form => fieldName-symbol or (instanceMethodName-symbol args*)
;;   Expands into a member access (.) of the first member on the first
;;   argument, followed by the next member on the result, etc. For
;;   instance:
;;   (.. System (getProperties) (get \"os.name\"))
;;   expands to:
;;   (. (. System (getProperties)) (get \"os.name\"))
;;   but is easier to write, read, and understand."
;;   {:added "1.0"}
;;   ([x form] `(. ~x ~form))
;;   ([x form & more] `(.. (. ~x ~form) ~@more)))

(defmacro ->
  "Threads the expr through the forms. Inserts x as the
  second item in the first form, making a list of it if it is not a
  list already. If there are more forms, inserts the first form as the
  second item in second form, etc."
  {:added "1.0"}
  [x & forms]
  (loop [x x, forms forms]
    (if forms
      (let [form (first forms)
            threaded (if (seq? form)
                       (with-meta `(~(first form) ~x ~@(next form)) (meta form))
                       (list form x))]
        (recur threaded (next forms)))
      x)))

(defmacro ->>
  "Threads the expr through the forms. Inserts x as the
  last item in the first form, making a list of it if it is not a
  list already. If there are more forms, inserts the first form as the
  last item in second form, etc."
  {:added "1.1"}
  [x & forms]
  (loop [x x, forms forms]
    (if forms
      (let [form (first forms)
            threaded (if (seq? form)
                       (with-meta `(~(first form) ~@(next form)  ~x) (meta form))
                       (list form x))]
        (recur threaded (next forms)))
      x)))

(defmacro comment
  "Ignores body, yields nil"
  {:added "1.0"}
  [& body])

(defmacro while
  "Repeatedly executes body while test expression is true. Presumes
  some side-effect will cause test to become false/nil. Returns nil"
  {:added "1.0"}
  [test & body]
  `(loop []
     (when ~test
       ~@body
       (recur))))

;; Simba-specific

;; ;; ;; METAPROGRAMMING

;; (def ^{:args '[string]
;;        :doc "Reads one object from the string."}
;;   read-string
;;   py/read_string)

;; (defmacro ^{:doc "Evaluates a single form (not string)."} 
;;   eval [ds]
;;   `(py/eval_sexp ~ds *env*))

;; (defmacro ^{:doc "short for 'print macro expansion'"} 
;;   pme [expr]
;;   `(print
;;     (macroexpand ~expr)))

;; ;; ;; TESTING
;; ;; ;; the test library is baked into the base library, because it is so lightweight and performance is not a huge concern

;; (def *tests-have-failed* false)

;; (defn single-test [name test result]
;;   (when (not (= test result))
;;     (def *tests-have-failed* true)
;;     (prn "❗️ Test failed: `" name "` was expected to be " result " but got " test " instead. \n")))

;; (defmacro test [& tests]
;;   (if (instance? (first tests) py/str)
;;     `(do (def *section-name* ~(first tests))
;;          ~(when (rest tests)
;;             `(test ~@(rest tests))))
;;     `(do
;;        (single-test *section-name* ~(first tests) ~(second tests))
;;        ~(when (rrest tests)
;;           `(test ~@(rrest tests))))))

;; (defmacro tests [name & tests]
;;   `(do
;;      (def *section-name* ~name)
;;      (prn "ℹ️ Testing `" ~name "`\n")
;;      (test ~@tests)
;;      (if *tests-have-failed*
;;        (prn "❌ Tests completed with some failures. \n")
;;        (prn "✅ Tests completed without failures. \n"))))

;; (defmacro time [& forms]
;;   `(do (def t (date))
;;        ~@forms
;;        (- (date) t)))

;; (defmacro pmt [& forms]
;;   `(print (measure-time ~@forms)))